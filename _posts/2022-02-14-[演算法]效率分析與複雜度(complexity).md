---
layout: post
title:  "[演算法]效率分析與複雜度(complexity)"
date:   2022-02-14 22:00:00 +0800
categories: 演算法
tags: 複雜度(complexity)
pin: false
---
演算法的目的在於改善一個東西或問題，並在從問題中找出現有最好的辦法

在程式語言中演算法是攸關時間與空間的重要角色，一個好的演算法可以節省許多時間與記憶體空間，而一個程式在執行時所佔用的記憶體空間也會反映出執行所需要的時間

因此才需要效率分析，但其實也不用要求的非常精準，只需要一個最後結果是好的且大家都能夠接受的就行了

## 一、效率分析
因為每一隻程式在不同硬體設備上執行所花的時間都不同，但演算法不是只適用於一台特定的硬體設備

因此分析方法必須是不受電腦設備、程式語言、程式設計者，以及實作上的細節影響

但我們可以從這個分析結論得知這個演算法效率如何

比如一個簡單的程式可能包含初始化指令、迴圈

那我們可以從迴圈的循環次數分析，但也可能迴圈內做了其他複雜的處理，又或者只是簡單的處理

在這種情況下，我們可以針對問題，忽略初始化、迴圈控制，其他例行程序

如下方常見的問題與會執行n次的基本運算方式，這些運算方式通常也是構成演算法執行瓶頸的一種，因此利用它們的執行次數來分析是很合理的選擇

| 問題 | 基本運算方式 | 
| -------- | -------- | 
| 1. 在一個序列中搜尋ｘ | 將ｘ跟序列裡的元素做比較 | 
| 2. 兩個實數矩陣相乘 | 實數相乘 | 
| 3. 做一個序列的排序 | 兩個元素做比較 | 

當我們想好一個基本運算方式且執行的運算數也大致上跟上表的運算方式的執行數成正比

那我們就有了一個評估演算法效率的準據

如此分析出來的結果就是 **演算法複雜度(complexity)**

所以演算法複雜度也是指這個演算法所執行的基本運算次數

## 二、複雜度

另外在演算法複雜度領域中，有分成 **時間複雜度(Time Complexity)** 與 **空間複雜度(Space Complexity)**

因時間複雜度遠比空間複雜度受重視，除非特別指明，不然一般提到複雜度都是指時間複雜度

演算法複雜度通常都是以 **big O** 來表示，常見的演算法複雜度有（由小到大排序）：

| 小| 常數 (constant) 時間 | Ｏ(1) | 
| ↓| 雙重對數 (doubly log) 時間 | Ｏ(log log n) | 
| ↓| 對數 (log) 時間 | Ｏ(log n) | 
| ↓| 線性 (linear) 時間 | Ｏ(n) | 
| ↓| n log n 時間 | Ｏ(n log n) | 
| ↓| 多項式 (polynomial) 時間 | Ｏ(n^a), a ∈ R^+ | 
| 大| 指數 (exponential) 時間 | Ｏ(2^n) | 

再大就是階層時間 big Ｏ(n!)

當n越大時，不同的複雜度也會有不同的成長情形

![](https://i.imgur.com/Non82uU.png)

---

### EX. 時間複雜度
#### Ｏ(1)
```c++
int x = 0;
int y = 1;
int temp = x;
x = y;
y = temp;
```

#### Ｏ(n)
```c++
for(int i=0;i<n;i++){
    x++;
}
```

#### Ｏ(log n)
```c++
int i = 0;
while(i<n){
    i = i * 2;
}
```

#### Ｏ(n log n)
```c++
for(int i=0;i<n;i++){
    int x = 1;
    while(x<n){
        x = x * 2;
    }
}
```

#### Ｏ(n^2)
```c++
for(int i=0;i<n;i++){
    for(int j=1;j<n;j++){
        x++;
    }
}
```

---

### EX. 空間複雜度
#### Ｏ(1)
```c++
int x = 0;
int y = 0;
x++;
y++;
```

#### Ｏ(n)
```c++
int[] newArray = new int[n];
for(int i=0;i<n;i++){
    newArray[i] = i;
}
```

##### 以上皆為自己整理的筆記，僅供參考與複習使用。